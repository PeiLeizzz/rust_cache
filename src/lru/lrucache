use crate::list::{Link, LinkedList, ListError};
    use std::{collections::HashMap, fmt::Display, hash::Hash};

    /// Cache block storing some key and value.
    pub struct Block<K, V> {
        pub key: K,
        pub value: V,
    }

    /// A Least-Recently-Used (LRU) Cache implemented using a generational arena
    /// based linked list and a hash map.
    pub struct LRUCache<K, V>
    where
        K: Eq + Hash,
    {
        blocks: LinkedList<Block<K, V>>,
        block_refs: HashMap<K, Link>,
    }

    #[derive(Debug, Clone, PartialEq)]
    pub enum CacheError {
        CacheBroken(ListError),
        CacheMiss,
    }

    impl Display for CacheError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match &self {
                CacheError::CacheBroken(list_error) => {
                    write!(f, "Cache storage is broken: ")?;
                    list_error.fmt(f)
                }
                CacheError::CacheMiss => write!(f, "Key not found in cache."),
            }
        }
    }

    impl<K, V> LRUCache<K, V>
    where
        K: Eq + Hash + Copy,
    {
        /// Creates an LRUCache instance with the given capacity. A zero capacity LRUCache is
        /// unusable.
        pub fn with_capacity(capacity: usize) -> Self {
            LRUCache {
                blocks: LinkedList::with_capacity(capacity),
                block_refs: HashMap::new(),
            }
        }

        /// Returns a reference to the value associated with the given key. If the key is not
        /// present in the cache, we return a "cache-miss" error. If the entry is found but
        /// cannot be fetched from the underlying storage, we return a "cache-broken" error.
        pub fn query(&mut self, key: &K) -> Result<&V, CacheError> {
            let link = self.block_refs.get(key).ok_or(CacheError::CacheMiss)?;
            self.blocks
                .reposition_to_tail(link)
                .map_err(CacheError::CacheBroken)?;
            let node = self.blocks.get(link).map_err(CacheError::CacheBroken)?;
            Ok(&node.value.value)
        }

        /// Removes the associated key value pair for the given key from this cache. If no
        /// entry is found, we return a "cache-miss" error. If the entry is found but cannot
        /// be fetched from the underlying in-memory storage, we return a "cache-broken" error.
        /// Returns the value associated, after removal with ownership.
        pub fn remove(&mut self, key: &K) -> Result<V, CacheError> {
            let link = self.block_refs.remove(key).ok_or(CacheError::CacheMiss)?;
            let block = self.blocks.remove(&link).map_err(CacheError::CacheBroken)?;
            Ok(block.value)
        }

        /// Inserts a new key value pair into this cache. If this cache is full, the least
        /// recently used entry is removed.
        pub fn insert(&mut self, key: K, value: V) -> Result<(), CacheError> {
            if let Some(link) = self.block_refs.get(&key) {
                self.blocks
                    .reposition_to_tail(link)
                    .map_err(CacheError::CacheBroken)?;
                let block_ref = self
                    .blocks
                    .get_mut_value(link)
                    .map_err(CacheError::CacheBroken)?;
                block_ref.value = value;
                return Ok(());
            }

            if self.blocks.is_full() {
                let block = self.blocks.pop_front().map_err(CacheError::CacheBroken)?;
                self.block_refs.remove(&block.key);
            }

            let link = self
                .blocks
                .push_back(Block { key, value })
                .map_err(CacheError::CacheBroken)?;
            self.block_refs.insert(key, link);

            Ok(())
        }
