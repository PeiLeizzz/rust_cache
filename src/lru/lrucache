use crate::list::{Link, LinkedList, ListError};
    use std::{collections::HashMap, fmt::Display, hash::Hash};

    /// 缓存块存储一些键和值。
    pub struct Block<K, V> {
        pub key: K,
        pub value: V,
    }

    ///使用分代竞技场实现的最近最少使用 (LRU) 缓存
    /// 基于链表和哈希映射。
    pub struct LRUCache<K, V>
    where
        K: Eq + Hash,
    {
        blocks: LinkedList<Block<K, V>>,
        block_refs: HashMap<K, Link>,
    }

    #[derive(Debug, Clone, PartialEq)]
    pub enum CacheError {
        CacheBroken(ListError),
        CacheMiss,
    }

    impl Display for CacheError {
        fn fmt(&self, f: &mut std::fmt::Formatter<'_>) -> std::fmt::Result {
            match &self {
                CacheError::CacheBroken(list_error) => {
                    write!(f, "Cache storage is broken: ")?;
                    list_error.fmt(f)
                }
                CacheError::CacheMiss => write!(f, "Key not found in cache."),
            }
        }
    }

    impl<K, V> LRUCache<K, V>
    where
        K: Eq + Hash + Copy,
    {
        /// 创建一个具有给定容量的 LRUCache 实例。零容量 LRUCache 是
        /// 无法使用。
        pub fn with_capacity(capacity: usize) -> Self {
            LRUCache {
                blocks: LinkedList::with_capacity(capacity),
                block_refs: HashMap::new(),
            }
        }

        /// 返回对与给定键关联的值的引用。如果钥匙不在
        /// 存在于缓存中，我们返回一个“cache-miss”错误。如果找到条目但
        /// 无法从底层存储中获取，我们返回“缓存损坏”错误。
        pub fn query(&mut self, key: &K) -> Result<&V, CacheError> {
            let link = self.block_refs.get(key).ok_or(CacheError::CacheMiss)?;
            self.blocks
                .reposition_to_tail(link)
                .map_err(CacheError::CacheBroken)?;
            let node = self.blocks.get(link).map_err(CacheError::CacheBroken)?;
            Ok(&node.value.value)
        }

        /// 从此缓存中删除给定键的关联键值对。如果不
        /// 条目被找到，我们返回一个“cache-miss”错误。如果找到条目但找不到
        /// 从底层内存存储中获取，我们返回一个“缓存损坏”错误。
        /// 在删除所有权后返回关联的值。
        pub fn remove(&mut self, key: &K) -> Result<V, CacheError> {
            let link = self.block_refs.remove(key).ok_or(CacheError::CacheMiss)?;
            let block = self.blocks.remove(&link).map_err(CacheError::CacheBroken)?;
            Ok(block.value)
        }

        /// 将一个新的键值对插入到这个缓存中。如果此缓存已满，则至少
        /// 最近使用的条目被删除。
        pub fn insert(&mut self, key: K, value: V) -> Result<(), CacheError> {
            if let Some(link) = self.block_refs.get(&key) {
                self.blocks
                    .reposition_to_tail(link)
                    .map_err(CacheError::CacheBroken)?;
                let block_ref = self
                    .blocks
                    .get_mut_value(link)
                    .map_err(CacheError::CacheBroken)?;
                block_ref.value = value;
                return Ok(());
            }

            if self.blocks.is_full() {
                let block = self.blocks.pop_front().map_err(CacheError::CacheBroken)?;
                self.block_refs.remove(&block.key);
            }

            let link = self
                .blocks
                .push_back(Block { key, value })
                .map_err(CacheError::CacheBroken)?;
            self.block_refs.insert(key, link);

            Ok(())
        }
