## LRU 缓存 - Rust 课程大作业

> 参考项目：https://github.com/arindas/generational-lru
> 
> 一个基于 generation 的 lru 实现
> 
> 特点：无 unsafe，无复杂的智能指针，底层通过封装 `Vec` 实现

### 开发流程
- 每个人基于最新的 `master` 建一个自己的分支，根据前面开发的模块进行后续的开发
- 如果前面的人对 api 出入参数有改动，新增函数后面再讨论如何修改
- 每个函数里外最好都写好**中文注释**，解释一下是什么意思，顺便也给自己梳理一下思路
- 最好有测试示例，并且只有测试中用到的函数尽量只写在测试模块中
- 执行 `commit` 之前最好进行一下 `rustfmt` 提高代码可读性
- 开发完 push 到自己的分支后提交 `pull request` 合并到 `master` 分支

### 任务分配
- @裴雷（`arena` 模块 + 部分 `list` 模块，12.5-12.7）+ 中期汇报
- @刘书伟（部分 `list` 模块 + 最好能够进行超时优化，12.8-12.12）
- @陈鹏郅 （`lrucache` 模块 + `main` 函数中给出使用示例，12.13-12.16）

> 结题汇报的时候，可能就 @裴雷 汇报也可能所有人一起，把各自做了什么说一下，如果有优化的话更好，可以详细说一下优化点以及如何做的优化

### 可能的优化点
1. 缓存插入时的自动淘汰：每个节点再维护一个最近活跃时间，插入时如果内存已满本身就要进行淘汰，淘汰完可以再检查下链表尾的节点是否有超时，如果有的话，就一直往前删直到链表为空或者遇到第一个没超时的节点，这样就实现了时间 + 空间的双淘汰制度
2. 查询时的自动淘汰：类似于 1，但是查询效率比较关键，最好不要等删完了再返回，是否可以做一个异步的操作？先返回给用户它的数据，然后后台异步淘汰超时的数据
3. 是否可以在 cache 中加一个回调函数？当查询 miss 的时候，通过这个回调函数去另外的地方再找（例如数据库、文件等），如果还找不到才是真正的 miss，类似于 [这里](https://geektutu.com/post/geecache-day2.html#3-1-%E5%9B%9E%E8%B0%83-Getter) 的实现
4. 并发安全的缓存？通过 Rust 的锁是否可以不改动内部代码就实现？
   > 个人感觉应该是可以直接支持并发的，否则 generation 没有应用场景

### 运行
```sh
cargo run
```