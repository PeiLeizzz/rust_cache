## LRU 缓存 - Rust 课程大作业

> 参考项目：https://github.com/arindas/generational-lru
> 
> 一个基于 generation 的 lru 实现
> 
> 特点：无 unsafe，无复杂的智能指针，底层通过封装 `Vec` 实现

### 开发流程
- 每个人基于最新的 `master` 建一个自己的分支，根据前面开发的模块进行后续的开发
- 如果前面的人对 api 出入参数有改动，新增函数后面再讨论如何修改
- 每个函数里外最好都写好**中文注释**，解释一下是什么意思，顺便也给自己梳理一下思路
- 最好有测试示例，并且只有测试中用到的函数尽量只写在测试模块中
- 执行 `commit` 之前最好进行一下 `rustfmt` 提高代码可读性
- 开发完 push 到自己的分支后提交 `pull request` 合并到 `master` 分支

### 任务分配
- @裴雷（`arena` 模块 + 部分 `list` 模块，12.5-12.7）+ 中期汇报
- @刘书伟（部分 `list` 模块 + 最好能够进行**异步 / 线程**超时优化，12.8-12.12）
- @陈鹏郅 （`lrucache` 模块 + `main` 函数中给出使用示例，12.13-12.16）

> 结题汇报的时候，可能就 @裴雷 汇报也可能所有人一起，把各自做了什么说一下，如果有优化的话更好，可以详细说一下优化点以及如何做的优化

### 可能的优化点
1. [✅ @裴雷]缓存插入时的自动淘汰：每个节点再维护一个最近活跃时间，插入时如果内存已满本身就要进行淘汰，淘汰完可以再检查下链表尾的节点是否有超时，如果有的话，就一直往前删直到链表为空或者遇到第一个没超时的节点，这样就实现了时间 + 空间的双淘汰制度
2. [ @刘书伟]用户操作时的自动淘汰：类似于第一点，但是用户的操作优先级更高，最好不要等删完了再返回，是否可以做一个异步的操作？先响应操作，然后后台异步淘汰超时的数据，或者通过后台线程轮询来实现
   > 采用定时线程可能的思路：在 `LRUCache` 模块封装 `LinkedList` 的时候，用 `Arc<>` 包裹，然后挂载一个 `static thread` 让它每隔一段时间执行
   > 
   > `LRUCache` 销毁的时候需要销毁该线程
   >
   > 难点在于 `&mut` 的争夺，在正常 `query / remove / insert` 的时候，能否暂停线程？等操作执行完再继续
   >
   > 应该让线程和 `LinkedList` 的同级而不是放在 `LinkedList` 内部，因为需要将删除的元素返回出来，再在 `Map` 中将其删除
   > 
   > 可以参考 [https://stackoverflow.com/questions/42043823/design-help-threading-within-a-struct](https://stackoverflow.com/questions/42043823/design-help-threading-within-a-struct)
3. [ @刘书伟]（尝试）并发安全的缓存？通过 Rust 的锁是否可以不改动内部代码就实现？
   > 个人感觉应该是可以直接支持并发的，否则 generation 没有应用场景
4. [ @陈鹏郅]优化实现 LRU-K / 2Q
   > LRU-K 是通过 `K` 个相同的缓存进行的（可能比较麻烦）
   > 
   > 2Q 是通过 `LRUCache + FIFO` 实现的（较容易）
   >
   > 可以参考 [https://segmentfault.com/a/1190000022558044](https://segmentfault.com/a/1190000022558044) 中的描述，2Q 应该不难
5. [ @陈鹏郅]是否可以在 cache 中加一个回调函数？当查询 miss 的时候，通过这个回调函数去另外的地方再找（例如数据库、文件等），如果还找不到才是真正的 miss
   > 类似于 [这里](https://geektutu.com/post/geecache-day2.html#3-1-%E5%9B%9E%E8%B0%83-Getter) 的实现


### 运行
```sh
cargo run
```